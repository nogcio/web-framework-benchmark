# UI / Templates Guide (wfb-server)

The dashboard UI is server-rendered with **Askama** templates and enhanced with **HTMX** for partial updates.

This guide documents the conventions used in `wfb-server/` so changes remain consistent.

## Where things live

- Templates root: `wfb-server/templates/`
  - `layouts/`: base layouts (HTML skeleton)
  - `pages/`: full pages (extend a layout)
  - `partials/`: HTMX partial responses and small shared fragments
  - `components/`: reusable UI components

- Web handlers: `wfb-server/src/handlers/web/`
  - Each page/partial typically has a small Rust "template context" struct annotated with `#[derive(Template)]`.

- Template helpers:
  - Routes: `wfb-server/src/routes.rs` generates a `crate::routes::tpl::Routes` helper for templates.
  - Filters: `wfb-server/src/filters.rs` defines Askama filters like `asset_path`, formatting helpers, and `icon`.

- Assets pipeline:
  - Source: `wfb-server/assets/src/` (Tailwind CSS + JS)
  - Build output: `wfb-server/assets/dist/` (fingerprinted files)
  - Mapping: `wfb-server/src/assets_manifest.rs` (generated by `build.rs`)

Note: the assets pipeline is executed by `wfb-server/build.rs` during Rust builds. It runs Tailwind CSS and esbuild; if `tailwindcss`/`esbuild` are not available on `PATH` (or via `TAILWINDCSS_BIN`/`ESBUILD_BIN`), it falls back to `npx`, which requires Node.js.

## Template context conventions ("props")

Prefer small, explicit variables over a single giant context object.

Common contexts used across pages:

- `chrome`: global chrome state (render duration, header mode, repo/contact, GitHub stars)
- `selection`: current run/env/test and lists for navigation
- `routes`: reverse-routing helper (`Routes`) used to build URLs in templates

Pages then add only what they need (e.g. `bench`, `benchmarks`).

## Routing and reverse routing

Do not hardcode URLs in templates.

- Add routes in `wfb-server/src/routes.rs`.
- If a route is used from templates, add a `[tpl ...]` marker in the route list so it generates a helper method on `Routes`.
- In templates, use `routes.*_url(...)` helpers.

This keeps `href`, `hx-get`, and `hx-push-url` consistent.

## Layout + HTMX contracts

### Base layout contract

`templates/layouts/base.rs.j2` defines the HTMX defaults:

- `hx-target="#wfb-page"`
- `hx-select="#wfb-page"`
- `hx-swap="outerHTML"`

Meaning: full page navigations (via `hx-boost`) expect responses that contain an element with `id="wfb-page"`.

### Chrome OOB contract

Header/sidebar/footer are designed to be swapped out-of-band (OOB):

- `components/header.rs.j2` → `id="wfb-header"` + `hx-swap-oob="true"`
- `components/sidebar.rs.j2` → `id="wfb-sidebar"` + `hx-swap-oob="true"`
- `components/footer.rs.j2` → `id="wfb-footer"` + `hx-swap-oob="true"`

For partial responses, prefer including the OOB chrome bundle via:

- `partials/htmx/macros.rs.j2` → `htmx::oob_chrome()`

This keeps chrome state in sync even when only a section updates.

### Partial response rule of thumb

- A **page** template extends `layouts/base.rs.j2` and renders the full `#wfb-page`.
- A **partial** template renders only the target fragment (e.g. `#wfb-results`) and may include OOB chrome updates.

## Macros and components (preferred patterns)

### HTMX wiring macros

Use `partials/htmx/macros.rs.j2` instead of hand-rolling attributes.

Examples:

- Results navigation: `htmx::wfb_results_anchor_attrs(run_id, env, test)`
- Lazy charts: `htmx::bench_charts_lazy_attrs(run_id, env, test, framework)`

This avoids subtle mismatches between `href`, `hx-get`, and `hx-push-url`.

### UI primitives macros

Use `partials/ui/macros.rs.j2` to normalize markup:

- Dropdown structure: `ui::dropdown(...)` (call-block/slot)
- Icons: `ui::icon(name, classes)` (backed by the `icon` filter)

Avoid copying raw dropdown HTML into multiple components.

### Component variants

Some components accept a `variant` variable in scope.

Pattern:

- Set `{% set variant = "mobile" %}` (or another supported value)
- `{% include "components/..." %}`

Keep variants small and explicit; prefer separate components if markup diverges heavily.

## Assets: how to reference CSS/JS/images

Always use the `asset_path` filter so fingerprinted assets resolve correctly:

- `<script src="{{ \"/js/foo.js\"|asset_path }}" defer></script>`
- `<link rel="stylesheet" href="{{ \"/css/app.css\"|asset_path }}">`
- `<img src="{{ \"/images/logo.svg\"|asset_path }}">`

Do not reference `assets/dist` filenames directly.

## Public site CSP notes

When `WFB_PUBLIC=1` is enabled, the server sets a strict `Content-Security-Policy` that allows scripts
only when they carry a per-request nonce.

- Prefer external JS files under `wfb-server/assets/src/js/`.
- If you must embed a `<script>` tag inside a template/partial (for example `type="application/json"` data),
  add `nonce="{{ csp_nonce }}"` and plumb `csp_nonce` through the Rust template context.

## Adding a new page (checklist)

1) Add a route in `wfb-server/src/routes.rs` (and a template helper `[tpl ...]` if the template needs it).

2) Add a handler in `wfb-server/src/handlers/web/`:
- Define a `#[derive(Template)]` context struct with `#[template(path = "pages/<name>.rs.j2")]`.
- Return `HtmlTemplate(YourTemplate { ... })`.
- Pass `routes: Routes` and the usual `chrome`/`selection` contexts.

3) Add a template in `wfb-server/templates/pages/`:
- `{% extends "layouts/base.rs.j2" %}`
- Fill `title`, optional `head`, and `content` blocks.

4) If the page uses custom JS/CSS:
- Add files under `wfb-server/assets/src/js` or `wfb-server/assets/src/css`.
- Reference them with `|asset_path`.

## Adding a new partial (HTMX) (checklist)

1) Decide the stable DOM id for the fragment (e.g. `#wfb-results`, `#bench-charts`).

2) Create a template under `templates/partials/...` that renders that fragment.

3) Add a handler that returns that partial template.

4) Prefer including `htmx::oob_chrome()` when the chrome should update alongside the fragment.

## Do / Don't

- Do: keep changes minimal; reuse existing components and macros.
- Do: use `Routes` for URLs and `asset_path` for assets.
- Do: keep DOM ids stable when used with `hx-select`.
- Don’t: hardcode routes, asset filenames, or duplicate dropdown/menu markup.
- Don’t: introduce a new frontend framework unless explicitly requested.
